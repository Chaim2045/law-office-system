# ×ª×›× ×•×Ÿ: updateTimesheetEntry â†’ Atomic Transaction

**×§×•×‘×¥:** functions/index.js
**×©×•×¨×•×ª × ×•×›×—×™×•×ª:** 4317-4579
**××˜×¨×”:** ×¢×˜×™×¤×” ×‘-db.runTransaction() ×œ××˜×•××™×•×ª ××œ××”

---

## ğŸ“‹ ××‘× ×” × ×•×›×—×™ (×œ× ××˜×•××™)

```
1. checkUserPermissions()        [auth check - ××—×•×¥ ×œ×¤×•× ×§×¦×™×”]
2. Validation                    [input validation]
3. entryRef.get()                [READ #1]
4. Security check                [permission validation]
5. entryRef.update()             [WRITE #1] â† ×œ× ××˜×•××™!
6. if (autoGenerated + taskId):
   - taskRef.get()               [READ #2]
   - taskRef.update()            [WRITE #2] â† ×œ× ××˜×•××™!
   - if (clientId):
     - clientRef.get()           [READ #3]
     - clientRef.update()        [WRITE #3] â† ×œ× ××˜×•××™!
```

---

## ğŸ¯ ××‘× ×” ×—×“×© (××˜×•××™)

```
1. checkUserPermissions()        [auth - ××—×•×¥ ×œ-transaction]
2. Validation                    [input - ××—×•×¥ ×œ-transaction]
3. db.runTransaction(async (transaction) => {
   // PHASE 1: READS
   - transaction.get(entryRef)
   - transaction.get(taskRef)    [if needed]
   - transaction.get(clientRef)  [if needed]

   // PHASE 2: CALCULATIONS
   - validations
   - calculations
   - data preparation

   // PHASE 3: WRITES
   - transaction.update(entryRef, ...)
   - transaction.update(taskRef, ...)   [if needed]
   - transaction.update(clientRef, ...) [if needed]
})
```

---

## 1ï¸âƒ£ Phase 1 â€” READS

### ××” × ×›× ×¡ ×œ-transaction.get():

#### ×§×¨×™××” #1: Entry (×ª××™×“)
```javascript
const entryRef = db.collection('timesheet_entries').doc(data.entryId);
const entryDoc = await transaction.get(entryRef);
```
**×ª× ××™:** ×ª××™×“
**××˜×¨×”:** ×§×¨×™××ª ×”×¨×©×•××” ×”×§×™×™××ª

#### ×§×¨×™××” #2: Task (×ª× ××™)
```javascript
if (data.autoGenerated && data.taskId) {
  const taskRef = db.collection('budget_tasks').doc(data.taskId);
  const taskDoc = await transaction.get(taskRef);
}
```
**×ª× ××™:** ×× `data.autoGenerated === true && data.taskId`
**××˜×¨×”:** ×§×¨×™××ª ×”××©×™××” ×œ×¢×“×›×•×Ÿ actualMinutes

#### ×§×¨×™××” #3: Client (×ª× ××™)
```javascript
if (data.autoGenerated && data.taskId && data.clientId) {
  const clientRef = db.collection('clients').doc(data.clientId);
  const clientDoc = await transaction.get(clientRef);
}
```
**×ª× ××™:** ×× `data.autoGenerated && data.taskId && data.clientId`
**××˜×¨×”:** ×§×¨×™××ª ×”×œ×§×•×— ×œ×¢×“×›×•×Ÿ hoursRemaining/services

---

### âš ï¸ ××” × ×©××¨ ××—×•×¥ ×œ-transaction:

#### checkUserPermissions() - ××—×•×¥!
```javascript
const user = await checkUserPermissions(context);
```
**×¡×™×‘×”:**
- ×–×” auth check, ×œ× data operation
- ×¦×¨×™×š ×œ×¨×•×¥ ×œ×¤× ×™ ×”-transaction
- ×œ× ××©×¤×™×¢ ×¢×œ consistency

---

## 2ï¸âƒ£ Phase 2 â€” CALCULATIONS

### Validations ×‘×ª×•×š Transaction:

#### Validation #1: Entry Exists
```javascript
if (!entryDoc.exists) {
  throw new functions.https.HttpsError('not-found', '×¨×©×•××ª ×©×¢×ª×•×Ÿ ×œ× × ××¦××”');
}
```

#### Validation #2: Security Check
```javascript
const entryData = entryDoc.data();
if (user.role !== 'admin' && entryData.employee !== user.email) {
  throw new functions.https.HttpsError('permission-denied', '××™×Ÿ ×”×¨×©××” ×œ×¢×¨×•×š ×¨×©×•××” ×–×•');
}
```

#### Validation #3: Task Exists (×× ×§×•×¨×)
```javascript
if (data.taskId && taskDoc && !taskDoc.exists) {
  // Task ×¦×¨×™×š ×œ×”×™×•×ª ×§×™×™× ×× ××‘×§×©×™× ×œ×¢×“×›×Ÿ ××•×ª×•
  throw new functions.https.HttpsError('not-found', '××©×™××” ×œ× × ××¦××”');
}
```

#### Validation #4: Client Exists (×× ×§×•×¨×)
```javascript
if (data.clientId && clientDoc && !clientDoc.exists) {
  throw new functions.https.HttpsError('not-found', '×œ×§×•×— ×œ× × ××¦×');
}
```

---

### Calculations:

#### Calculation #1: minutesDiff
```javascript
const minutesDiff = data.minutes - entryData.minutes;
const hoursDiff = minutesDiff / 60;
```
**××˜×¨×”:** ×—×™×©×•×‘ ×”×”×¤×¨×© ×œ×¢×“×›×•×Ÿ task + client

#### Calculation #2: fixedEditHistory
```javascript
const fixedEditHistory = data.editHistory.map(edit => {
  const editedAt = edit.editedAt;

  if (editedAt && typeof editedAt === 'object' && editedAt._methodName === 'FieldValue.serverTimestamp') {
    return { ...edit, editedAt: admin.firestore.Timestamp.now() };
  }

  if (typeof editedAt === 'string') {
    return { ...edit, editedAt: admin.firestore.Timestamp.fromDate(new Date(editedAt)) };
  }

  if (editedAt && editedAt.seconds !== undefined && editedAt.nanoseconds !== undefined) {
    return edit;
  }

  return { ...edit, editedAt: admin.firestore.Timestamp.now() };
});
```
**××˜×¨×”:** ×”××¨×ª timestamps ×œ-Firestore format

#### Calculation #3: Task Updates (×× ×¨×œ×•×•× ×˜×™)
```javascript
if (taskDoc && taskDoc.exists) {
  const taskData = taskDoc.data();

  const updateObj = {
    actualMinutes: admin.firestore.FieldValue.increment(minutesDiff),
    lastActivity: admin.firestore.FieldValue.serverTimestamp()
  };

  // Update task.timeEntries array
  if (taskData.timeEntries && Array.isArray(taskData.timeEntries)) {
    const updatedTimeEntries = taskData.timeEntries.map(entry => {
      if (entry.entryId === data.entryId) {
        return {
          ...entry,
          minutes: data.minutes,
          hours: data.minutes / 60,
          action: data.action || entry.action,
          lastEditedAt: admin.firestore.FieldValue.serverTimestamp()
        };
      }
      return entry;
    });
    updateObj.timeEntries = updatedTimeEntries;
  }
}
```

#### Calculation #4: Client Updates (×× ×¨×œ×•×•× ×˜×™)
```javascript
if (clientDoc && clientDoc.exists) {
  const clientData = clientDoc.data();

  // Hours-based client
  if (clientData.procedureType === 'hours' && clientData.services && clientData.services.length > 0) {
    let service = data.serviceId
      ? clientData.services.find(s => s.id === data.serviceId)
      : clientData.services[0];

    if (service) {
      const activePackage = DeductionSystem.getActivePackage(service);

      if (activePackage) {
        activePackage.hoursUsed = (activePackage.hoursUsed || 0) + hoursDiff;
        activePackage.hoursRemaining = (activePackage.hoursRemaining || 0) - hoursDiff;

        // Prepare client update
        clientUpdateData = {
          services: clientData.services,
          minutesRemaining: admin.firestore.FieldValue.increment(-minutesDiff),
          hoursRemaining: admin.firestore.FieldValue.increment(-hoursDiff),
          lastActivity: admin.firestore.FieldValue.serverTimestamp()
        };
      }
    }
  }

  // Legal procedure client
  else if (data.serviceType === 'legal_procedure' && data.serviceId) {
    const service = clientData.services?.find(s => s.id === data.serviceId);

    if (service && service.type === 'legal_procedure') {
      const stages = service.stages || [];
      const currentStageIndex = stages.findIndex(s => s.id === service.currentStage);

      if (currentStageIndex !== -1) {
        const currentStage = stages[currentStageIndex];
        const activePackage = DeductionSystem.getActivePackage(currentStage);

        if (activePackage) {
          activePackage.hoursUsed = (activePackage.hoursUsed || 0) + hoursDiff;
          activePackage.hoursRemaining = (activePackage.hoursRemaining || 0) - hoursDiff;

          clientUpdateData = {
            services: clientData.services,
            lastActivity: admin.firestore.FieldValue.serverTimestamp()
          };
        }
      }
    }
  }
}
```

---

## 3ï¸âƒ£ Phase 3 â€” WRITES

### Write #1: Entry (×ª××™×“)
```javascript
const entryUpdateData = {
  date: data.date,
  minutes: data.minutes,
  hours: data.minutes / 60,
  editHistory: fixedEditHistory,
  lastEditedAt: admin.firestore.FieldValue.serverTimestamp(),
  lastEditedBy: user.username
};

if (data.action !== undefined) {
  entryUpdateData.action = data.action;
}

transaction.update(entryRef, entryUpdateData);
```
**×ª× ××™:** ×ª××™×“
**×¡×“×¨:** ×¨××©×•×Ÿ

---

### Write #2: Task (×ª× ××™)
```javascript
if (data.autoGenerated && data.taskId && taskDoc && taskDoc.exists) {
  transaction.update(taskRef, updateObj);
}
```
**×ª× ××™:** ×× autoGenerated + taskId + task ×§×™×™×
**×¡×“×¨:** ×©× ×™

---

### Write #3: Client (×ª× ××™)
```javascript
if (data.autoGenerated && data.taskId && data.clientId && clientDoc && clientDoc.exists && clientUpdateData) {
  transaction.update(clientRef, clientUpdateData);
}
```
**×ª× ××™:** ×× autoGenerated + taskId + clientId + client ×§×™×™× + ×™×© ×¢×“×›×•×Ÿ
**×¡×“×¨:** ×©×œ×™×©×™

---

## 4ï¸âƒ£ ××” ×œ× ××©×ª× ×”

### âœ… × ×©××¨ ×–×”×”:

#### 1. Input Validation (××—×•×¥ ×œ-transaction)
```javascript
if (!data.entryId) {
  throw new functions.https.HttpsError('invalid-argument', '×—×¡×¨ ××–×”×” ×¨×©×•××”');
}
if (!data.date) {
  throw new functions.https.HttpsError('invalid-argument', '×—×¡×¨ ×ª××¨×™×š');
}
if (typeof data.minutes !== 'number' || data.minutes <= 0) {
  throw new functions.https.HttpsError('invalid-argument', '×“×§×•×ª ×—×™×™×‘×•×ª ×œ×”×™×•×ª ××¡×¤×¨ ×—×™×•×‘×™');
}
if (!data.editHistory || !Array.isArray(data.editHistory)) {
  throw new functions.https.HttpsError('invalid-argument', '×—×¡×¨×” ×”×™×¡×˜×•×¨×™×™×ª ×¢×¨×™×›×”');
}
```

#### 2. Error Handling (×—×™×¦×•× ×™)
```javascript
try {
  // ...
} catch (error) {
  console.error('Error in updateTimesheetEntry:', error);

  if (error instanceof functions.https.HttpsError) {
    throw error;
  }

  throw new functions.https.HttpsError(
    'internal',
    `×©×’×™××” ×‘×¢×“×›×•×Ÿ ×¨×©×•××ª ×©×¢×ª×•×Ÿ: ${error.message}`
  );
}
```

#### 3. Response Format
```javascript
return {
  success: true,
  entryId: data.entryId
};
```

#### 4. Console Logs
- ×›×œ ×”-console.log/warn × ×©××¨×™× (×œ×¦×•×¨×›×™ debug)

---

## 5ï¸âƒ£ Risks & Mitigation

### Risk #1: Transaction Timeout
**×‘×¢×™×”:** Transaction ×¢× 3+ documents ×™×›×•×œ ×œ×§×—×ª ×–××Ÿ
**Mitigation:**
- Firestore transactions ××ª×•×›× × ×•×ª ×œ×–×”
- Timeout default ×”×•× 60 ×©× ×™×•×ª
- ×‘×¤×•×¢×œ: 3 reads + 3 writes = ~100-200ms

**×¤×¢×•×œ×”:** ××™×Ÿ ×¦×•×¨×š ×‘×©×™× ×•×™

---

### Risk #2: Transaction Retry
**×‘×¢×™×”:** ×× ×™×© write conflict, Transaction ×™×¨×™×¥ ××—×“×© ××ª ×›×œ ×”×œ×•×’×™×§×”
**Mitigation:**
- ×”×œ×•×’×™×§×” idempotent (× ×™×ª×Ÿ ×œ×”×¨×¦×” ××—×“×©)
- ×—×™×©×•×‘×™× ××‘×•×¡×¡×™-×§×¨×™××” (×œ× side effects)
- Firestore ××˜×¤×œ ×‘×–×” ××•×˜×•××˜×™×ª

**×¤×¢×•×œ×”:** ××™×Ÿ ×¦×•×¨×š ×‘×©×™× ×•×™

---

### Risk #3: Backward Compatibility - Client Calls
**×‘×¢×™×”:** ×”×× ×§×¨×™××•×ª ×§×™×™××•×ª ××”×œ×§×•×— ×™××©×™×›×• ×œ×¢×‘×•×“?
**× ×™×ª×•×—:**
- Input format ×œ× ××©×ª× ×”
- Output format ×œ× ××©×ª× ×”
- ×¨×§ ×”-implementation ×”×¤× ×™××™ ××©×ª× ×”

**Mitigation:** âœ… 100% backward compatible

**×¤×¢×•×œ×”:** ××™×Ÿ ×¦×•×¨×š ×‘×©×™× ×•×™

---

### Risk #4: Performance Degradation
**×‘×¢×™×”:** Transaction ×™×›×•×œ ×œ×”×™×•×ª ×™×•×ª×¨ ××™×˜×™ ××›×ª×™×‘×•×ª ×¨×’×™×œ×•×ª
**× ×™×ª×•×—:**
```
×œ×¤× ×™ (non-atomic):
- 1 read  (entry)
- 1 write (entry)
- 1 read  (task)   [×ª× ××™]
- 1 write (task)   [×ª× ××™]
- 1 read  (client) [×ª× ××™]
- 1 write (client) [×ª× ××™]
×¡×”"×›: 3 reads + 3 writes (worst case)

××—×¨×™ (atomic):
- 3 reads  ×‘×ª×•×š transaction
- 3 writes ×‘×ª×•×š transaction
×¡×”"×›: 3 reads + 3 writes (worst case)
```

**×ª×•×¦××”:** ××•×ª×• ××¡×¤×¨ operations, ××‘×œ ×¢×›×©×™×• ××˜×•××™!

**×¤×¢×•×œ×”:** ××™×Ÿ ×¤×’×™×¢×” ×‘×‘×™×¦×•×¢×™×

---

### Risk #5: DeductionSystem.getActivePackage() Side Effects
**×‘×¢×™×”:** ×”×× ×”×¤×•× ×§×¦×™×” ×”×–×• ×¢×•×©×” side effects?
**× ×™×ª×•×—:**
```javascript
DeductionSystem.getActivePackage(service)
```
- ××—×–×™×¨ reference ×œ×—×‘×™×œ×” ×‘-service.packages
- ×œ× ×¢×•×©×” database writes
- ×¨×§ ××¦×™××ª ×”×—×‘×™×œ×” ×”×¤×¢×™×œ×”

**Mitigation:** âœ… Safe to use inside transaction

**×¤×¢×•×œ×”:** ××™×Ÿ ×¦×•×¨×š ×‘×©×™× ×•×™

---

### Risk #6: Mutation of clientData.services
**×‘×¢×™×”:** ×”×× ×× ×—× ×• mutating ××ª ×”××•×‘×™×™×§×˜ clientData.services?
**× ×™×ª×•×—:**
```javascript
const activePackage = DeductionSystem.getActivePackage(service);
activePackage.hoursUsed = (activePackage.hoursUsed || 0) + hoursDiff;  // â† mutation!
activePackage.hoursRemaining = (activePackage.hoursRemaining || 0) - hoursDiff;  // â† mutation!

await clientRef.update({
  services: clientData.services,  // â† ×©×•×œ×—×™× ××ª ×”××•×‘×™×™×§×˜ ×©×”×©×ª× ×”
  ...
});
```

**×–×” OK ×‘-Transaction ×›×™:**
- ×”××•×‘×™×™×§×˜ × ×§×¨× ×‘×ª×•×š ×”-transaction
- ×”×©×™× ×•×™×™× × ×©×œ×—×™× ×‘×ª×•×š transaction.update()
- ×× ×™×© retry, ×›×œ ×”×œ×•×’×™×§×” ×¨×¦×” ××—×“×© ×¢× read ×—×“×©

**Mitigation:** âœ… Pattern × ×›×•×Ÿ

**×¤×¢×•×œ×”:** ××™×Ÿ ×¦×•×¨×š ×‘×©×™× ×•×™

---

### Risk #7: Multiple Clients Editing Same Entry
**×‘×¢×™×”:** ×©× ×™ ××©×ª××©×™× ×¢×•×¨×›×™× ××ª ××•×ª×” ×¨×©×•××” ×‘×•-×–×× ×™×ª
**×œ×¤× ×™ (non-atomic):**
```
User A: READ entry (minutes=60)
User B: READ entry (minutes=60)
User A: WRITE entry (minutes=90) â†’ client gets minutesDiff=+30
User B: WRITE entry (minutes=45) â†’ client gets minutesDiff=-15
×ª×•×¦××”: client × ×•×ª×¨ ×¢× minutesDiff=-15 ×‘×œ×‘×“! (×—×™×©×•×‘ ×©×œ A ××‘×“)
```

**××—×¨×™ (atomic):**
```
User A: Transaction START
  - READ entry (minutes=60)
  - WRITE entry (minutes=90)
  - WRITE client (minutesDiff=+30)
User A: Transaction COMMIT âœ…

User B: Transaction START
  - READ entry (minutes=90)  â† ×§×•×¨× ××ª ×”×¢×¨×š ×”××¢×•×“×›×Ÿ!
  - WRITE entry (minutes=45)
  - WRITE client (minutesDiff=-45)
User B: Transaction COMMIT âœ…

×ª×•×¦××”: client ××§×‘×œ ×©× ×™ ×¢×“×›×•× ×™× × ×›×•× ×™×: +30 ×•××– -45
```

**Mitigation:** âœ… Transaction ×¤×•×ª×¨ ××ª ×”×‘×¢×™×”!

**×¤×¢×•×œ×”:** ×–×• ×‘×“×™×•×§ ×”××˜×¨×” ×©×œ ×”-refactor

---

## ğŸ“Š ×¡×™×›×•× ×ª×›× ×•×Ÿ

### Structure:
```javascript
exports.updateTimesheetEntry = functions.https.onCall(async (data, context) => {
  try {
    // 1. Auth check (OUTSIDE transaction)
    const user = await checkUserPermissions(context);

    // 2. Input validation (OUTSIDE transaction)
    if (!data.entryId) throw ...
    if (!data.date) throw ...
    if (!data.minutes) throw ...
    if (!data.editHistory) throw ...

    // 3. Prepare refs (OUTSIDE transaction)
    const entryRef = db.collection('timesheet_entries').doc(data.entryId);
    const taskRef = data.taskId ? db.collection('budget_tasks').doc(data.taskId) : null;
    const clientRef = data.clientId ? db.collection('clients').doc(data.clientId) : null;

    // 4. ATOMIC TRANSACTION
    await db.runTransaction(async (transaction) => {
      // PHASE 1: READS
      const entryDoc = await transaction.get(entryRef);
      const taskDoc = taskRef ? await transaction.get(taskRef) : null;
      const clientDoc = clientRef ? await transaction.get(clientRef) : null;

      // PHASE 2: VALIDATIONS + CALCULATIONS
      // - validate entry exists
      // - security check
      // - calculate minutesDiff
      // - fix editHistory
      // - prepare task updates
      // - prepare client updates

      // PHASE 3: WRITES
      transaction.update(entryRef, entryUpdateData);
      if (taskDoc?.exists) transaction.update(taskRef, taskUpdateData);
      if (clientDoc?.exists && clientUpdateData) transaction.update(clientRef, clientUpdateData);
    });

    // 5. Success response
    return { success: true, entryId: data.entryId };

  } catch (error) {
    // Error handling (unchanged)
  }
});
```

### Changes Summary:
- âœ… Input validation: × ×©××¨ ××—×•×¥ ×œ-transaction
- âœ… Auth check: × ×©××¨ ××—×•×¥ ×œ-transaction
- ğŸ”„ 3-4 reads: ×¢×•×‘×¨×™× ×œ-transaction.get()
- ğŸ”„ 3-4 writes: ×¢×•×‘×¨×™× ×œ-transaction.update()
- âœ… Error handling: × ×©××¨ ×œ×œ× ×©×™× ×•×™
- âœ… Response format: × ×©××¨ ×œ×œ× ×©×™× ×•×™
- âœ… 100% backward compatible

### Benefits:
- ğŸ¯ All-or-nothing guarantee
- ğŸ¯ No partial updates
- ğŸ¯ Race condition protection
- ğŸ¯ Data consistency guaranteed

### Risks:
- âœ… Performance: ××•×ª×• ××¡×¤×¨ operations
- âœ… Compatibility: 100% backward compatible
- âœ… Side effects: ××™×Ÿ
- âœ… Retry logic: Firestore ××˜×¤×œ ××•×˜×•××˜×™×ª

---

**×¡×˜×˜×•×¡:** ××•×›×Ÿ ×œ×™×™×©×•× âœ…

