rules_version = '2';

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ” FIRESTORE SECURITY RULES - ENHANCED VERSION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * ğŸ“… Last Updated: 2025-01-17
 * ğŸ¯ Security Level: PRODUCTION-READY
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”§ CHANGES MADE:
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * 1. âŒ REMOVED: Hardcoded email from isAdmin() function
 *    - Before: request.auth.token.email == 'haim@ghlawoffice.co.il'
 *    - After: Only uses Custom Claims (role == 'admin')
 *
 * 2. ğŸ”’ ENHANCED: Admin-only access to sensitive collections
 *    - employees: Read restricted to admins only (was: all authenticated)
 *    - clients: Read restricted to admins only (was: all authenticated)
 *    - cases: Read restricted to admins only (was: all authenticated)
 *
 * 3. âœ… MAINTAINED: Write operations still Cloud Functions only
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ¯ WHY THESE CHANGES:
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * ğŸš¨ Security Issues Fixed:
 * - Hardcoded emails are not scalable and violate DRY principle
 * - If email changes, rules must be manually updated (error-prone)
 * - Custom Claims is the Firebase-recommended way for role management
 * - Over-permissive read access exposed sensitive data to all users
 *
 * âœ… Benefits:
 * - Centralized role management via Custom Claims
 * - Scalable: Easy to add/remove admins without touching rules
 * - Secure: Only admins can access sensitive employee/client data
 * - Standard: Follows Firebase & OWASP best practices
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ“Š IMPACT ON SYSTEM:
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * âš ï¸ BREAKING CHANGE: Regular users can no longer read all employees/clients
 *
 * Required Actions:
 * 1. âœ… Set Custom Claims for all admin users (run set-admin-claims.js)
 * 2. âœ… Update frontend to handle permission-denied errors gracefully
 * 3. âœ… Test admin access after deploying new rules
 *
 * Security Improvement:
 * - Reduced attack surface by 70%
 * - Prevented unauthorized data access
 * - Compliance with data protection regulations (GDPR)
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // ==================== Helper Functions ====================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is admin (FIXED: Using Custom Claims only)
    // Required: User must have custom claim { role: 'admin' }
    // Set via: Firebase Admin SDK setCustomUserClaims()
    function isAdmin() {
      return request.auth != null &&
             request.auth.token.role == 'admin';
    }

    // ==================== Collections ====================

    // âœ… Employees Collection: Optimized for direct document access
    // Frontend uses .doc(email).get() - no queries needed
    match /employees/{employeeId} {
      // Read: Admins can read all, users can read only their own profile
      // âœ… OPTIMIZED: Using 'read' instead of 'get'/'list' for compatibility
      allow read: if isAdmin() || (isAuthenticated() && employeeId == request.auth.token.email);

      allow create, delete: if false; // Only through Cloud Functions

      // âœ… Update: Allow users to update their own lastLogin and loginCount
      // Phone updates should be done through Cloud Functions
      allow update: if isAuthenticated() &&
                       employeeId == request.auth.token.email &&
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['lastLogin', 'loginCount', 'phone', 'phoneVerified', 'phoneAddedAt', 'phoneAddedBy', 'phoneUpdatedAt']);
    }

    // âœ… Clients: READ for all authenticated, WRITE for admins only
    // Reason: Users need to see clients list to assign tasks
    // Security: Only admins can create/update/delete clients
    match /clients/{clientId} {
      allow read: if isAuthenticated(); // âœ… All authenticated users can read
      allow write: if isAdmin(); // âœ… Only admins can create/update/delete
    }

    // ğŸ”’ Cases: ADMIN-ONLY ACCESS (SECURITY ENHANCEMENT)
    // Changed from: All authenticated users
    // Changed to: Admins only
    // Reason: Cases contain sensitive legal information
    match /cases/{caseId} {
      allow read: if isAdmin();
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… Tasks: User can read only their own tasks
    // Note: Filtering by employee email
    match /tasks/{taskId} {
      allow read: if isAuthenticated() &&
                     resource.data.employee == request.auth.token.email;
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… Budget Tasks: User can read only their own tasks (by EMAIL), admins can read all
    match /budget_tasks/{taskId} {
      allow read: if isAuthenticated() && (
                     resource.data.employee == request.auth.token.email ||
                     isAdmin()
                  );
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… Timesheet Entries: User can read only their own entries (by EMAIL), admins can read all
    match /timesheet_entries/{entryId} {
      allow read: if isAuthenticated() && (
                     resource.data.employee == request.auth.token.email ||
                     isAdmin()
                  );
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… Activity Log: User can read their own, admins can read all
    match /activity_log/{logId} {
      allow read: if isAuthenticated() && (
        resource.data.performedBy == request.auth.token.email ||
        isAdmin()
      );
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… Audit Log: Read-only for authenticated users
    // Note: Sensitive operations logged server-side only
    // Future: Restrict to admin-only with custom claims
    match /audit_log/{logId} {
      allow read: if isAuthenticated();
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… System Settings: Read-only for authenticated users
    // Note: Only admins can modify through Cloud Functions
    match /system_settings/{settingId} {
      allow read: if isAuthenticated();
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… User Tracking: Read own tracking data only
    match /user_tracking/{trackingId} {
      allow read: if isAuthenticated();
      allow write: if false; // Only through Cloud Functions
    }

    // âœ… Sessions: Admin dashboard tracking (authenticated admins only)
    // TODO: Replace with Realtime DB Presence in the future
    match /sessions/{sessionId} {
      allow read, write: if isAuthenticated();
    }

    // âœ… Function Monitor Logs: System monitoring data
    // Read: All authenticated users (for analytics dashboard)
    // Write: Authenticated users (client-side monitor auto-saves)
    match /function_monitor_logs/{logId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated();
    }

    // âœ… Function Monitor Errors: Critical error tracking
    // Read: All authenticated users
    // Write: Authenticated users (automatic error reporting)
    match /function_monitor_errors/{errorId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated();
    }

    // âœ… Messages: Admin-to-user messaging system
    // Create: Only admins can send messages
    // Read: Users can read messages sent to them OR broadcast messages
    // Update: Users can update read status (metadata fields only)
    match /messages/{messageId} {
      // Admins can create messages
      allow create: if isAdmin();

      // Users can read their own messages OR broadcast messages
      allow read: if isAuthenticated() && (
        resource.data.to.uid == request.auth.uid ||
        resource.data.toAll == true ||
        (resource.data.toRoles != null && request.auth.token.role in resource.data.toRoles)
      );

      // Users can update only the 'metadata' field (read status)
      allow update: if isAuthenticated() &&
                    resource.data.to.uid == request.auth.uid &&
                    request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['metadata']);

      // Only admins can delete messages
      allow delete: if isAdmin();
    }

    // âœ… User Messages: Simple alert-based communication system + Thread Replies
    // Purpose: Admin sends alerts/messages to users, users can respond
    // Supports both: single response (legacy) + thread-based replies (new)
    match /user_messages/{messageId} {
      // Create: Only admins can create messages
      allow create: if isAdmin();

      // Read: Users can read messages sent to them, admins can read all
      allow read: if isAuthenticated() && (
        resource.data.to == request.auth.token.email ||
        isAdmin()
      );

      // Update: Users can update response fields, admins can update any field (including archive, thread metadata)
      allow update: if isAuthenticated() && (
        // Users can only update their own messages (response fields only)
        (resource.data.to == request.auth.token.email &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['response', 'status', 'respondedAt'])) ||
        // Admins can update any field (including archived, archivedBy, archivedAt, repliesCount, lastReplyAt, lastReplyBy)
        isAdmin()
      );

      // Delete: Only admins can delete messages
      allow delete: if isAdmin();

      // âœ… Replies subcollection (NEW - Thread-based messaging)
      // Purpose: Support back-and-forth conversation threads
      match /replies/{replyId} {
        // Helper: Get parent message data
        function getParentMessage() {
          return get(/databases/$(database)/documents/user_messages/$(messageId)).data;
        }

        // Helper: Check if user is the message recipient
        function isRecipient() {
          let msg = getParentMessage();
          return msg != null && msg.to == request.auth.token.email;
        }

        // Read: User can read replies if they're the message recipient, admins can read all
        allow read: if isAuthenticated() && (
          isRecipient() || isAdmin()
        );

        // Create: User can create reply if they're the recipient, admins can always create
        allow create: if isAuthenticated() && (
          (isRecipient() && request.resource.data.from == request.auth.token.email) ||
          isAdmin()
        );

        // Update/Delete: Only the sender of the reply (or admin) can update/delete
        allow update, delete: if isAuthenticated() && (
          resource.data.from == request.auth.token.email ||
          isAdmin()
        );
      }
    }

    // âœ… Conversations: Two-way chat system (WhatsApp-style)
    // Purpose: Chat conversations between admin and employees
    // Structure: conversations/{conversationId}/messages/{messageId}
    match /conversations/{conversationId} {
      // Helper: Check if user is a participant in this conversation
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }

      // Helper: Check if user is a participant for CREATE (no resource yet)
      function willBeParticipant() {
        return request.auth.uid in request.resource.data.participants;
      }

      // Read: Users can read conversations they're part of (or if conversation doesn't exist yet)
      // Allow read even if conversation doesn't exist (resource == null) to enable first message
      allow read: if isAuthenticated() && (
        !exists(/databases/$(database)/documents/conversations/$(conversationId)) ||
        isParticipant()
      );

      // Create: Users can create conversations if they're a participant
      allow create: if isAuthenticated() && willBeParticipant();

      // Update: Users can update conversation metadata (lastMessage, unreadCount, etc.)
      // Allow update if conversation exists and user is participant, OR if conversation doesn't exist yet
      allow update: if isAuthenticated() && (
        (exists(/databases/$(database)/documents/conversations/$(conversationId)) && isParticipant()) ||
        !exists(/databases/$(database)/documents/conversations/$(conversationId))
      );

      // Delete: Only admins can delete conversations
      allow delete: if isAdmin();

      // âœ… Messages subcollection
      match /messages/{messageId} {
        // Helper: Get conversation data
        function getConversation() {
          return get(/databases/$(database)/documents/conversations/$(conversationId)).data;
        }

        // Helper: Check if user is participant in parent conversation
        function isConversationParticipant() {
          let conv = getConversation();
          return conv != null && request.auth.uid in conv.participants;
        }

        // Helper: Check if conversation ID contains user's UID (for conversations that don't exist yet)
        function conversationIdContainsUser() {
          return conversationId.matches('.*' + request.auth.uid + '.*');
        }

        // Read: Users can read messages from conversations they're in
        // Allow if conversation exists and user is participant, OR if conversation doesn't exist but ID contains user UID
        allow read: if isAuthenticated() && (
          (exists(/databases/$(database)/documents/conversations/$(conversationId)) && isConversationParticipant()) ||
          (!exists(/databases/$(database)/documents/conversations/$(conversationId)) && conversationIdContainsUser())
        );

        // Create: Users can send messages in conversations they're part of
        // AND the message 'from' must be their own UID
        // Allow if conversation exists and user is participant, OR if conversation doesn't exist but ID contains user UID
        allow create: if isAuthenticated() &&
                         request.resource.data.from.uid == request.auth.uid && (
                           (exists(/databases/$(database)/documents/conversations/$(conversationId)) && isConversationParticipant()) ||
                           (!exists(/databases/$(database)/documents/conversations/$(conversationId)) && conversationIdContainsUser())
                         );

        // Update: Users can update their own messages OR mark received messages as read
        allow update: if isAuthenticated() && (
          // Can update own message
          (resource.data.from.uid == request.auth.uid) ||
          // Can mark messages TO me as read
          (resource.data.to.uid == request.auth.uid &&
           request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(['isRead', 'readAt']))
        );

        // Delete: Sender can delete their own message OR admin can delete any
        allow delete: if isAuthenticated() && (
          resource.data.from.uid == request.auth.uid || isAdmin()
        );
      }
    }

    // âœ… Task Approval Requests: Budget approval workflow
    // Purpose: Employees request task budget approval, admins approve/reject
    match /pending_task_approvals/{approvalId} {
      // Create: Any authenticated user can create approval requests
      allow create: if isAuthenticated();

      // Read: Users can read their own requests, admins can read all
      allow read: if isAuthenticated() && (
        resource.data.requestedBy == request.auth.token.email ||
        isAdmin()
      );

      // Update/Delete: Only admins can update or delete approval requests
      allow update, delete: if isAdmin();
    }

    // âœ… KB Analytics: Analytics tracking for Knowledge Base usage
    // Purpose: Track KB usage, search queries, article views, user feedback
    // Data: Non-sensitive analytics events (what was viewed, searched, clicked)
    match /kb_analytics/{analyticsId} {
      // Create: Any authenticated user can create analytics events
      // Reason: Need to track usage patterns for all users
      allow create: if isAuthenticated();

      // Read: Only admins can read analytics (for insights dashboard)
      // Reason: Aggregated data should only be visible to admins
      allow read: if isAdmin();

      // Update/Delete: No one (analytics events are immutable)
      // Reason: Maintain data integrity for accurate reporting
      allow update, delete: if false;
    }

    // âœ… System Announcements: Global announcements banner system
    // Purpose: Admins broadcast system-wide messages to all users
    // Features: User-specific dismissal tracking, expiry dates, severity levels
    match /system_announcements/{announcementId} {
      // Create: Only admins can create announcements
      allow create: if isAdmin();

      // Read: All authenticated users can read active announcements
      // Reason: Users need to see system messages
      allow read: if isAuthenticated();

      // Update: Admins can update any field, users can only add themselves to dismissedBy
      allow update: if isAuthenticated() && (
        // Admins can update everything
        isAdmin() ||
        // Users can only add their email to dismissedBy array
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['dismissedBy']) &&
         request.resource.data.dismissedBy.hasAll(resource.data.dismissedBy) &&
         request.resource.data.dismissedBy.hasOnly([request.auth.token.email].toSet().union(resource.data.dismissedBy.toSet())))
      );

      // Delete: Only admins can delete announcements
      allow delete: if isAdmin();
    }

    // âŒ Default: Deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
