class l{constructor(){this.db=null,this.currentUser=null}init(n,t){this.db=n,this.currentUser=t,console.log("✅ TaskApprovalService initialized")}async createApprovalRequest(n,t,e,r){try{const s={taskId:n,requestedBy:e,requestedByName:r||e,requestedAt:new Date,requestedMinutes:parseInt(t.estimatedMinutes)||0,taskData:{description:t.description||"",clientId:t.clientId||"",clientName:t.clientName||"",caseId:t.caseId||"",estimatedMinutes:parseInt(t.estimatedMinutes)||0},status:"pending",reviewedBy:null,reviewedAt:null,approvedMinutes:null,adminNotes:null,rejectionReason:null},a=await this.db.collection("pending_task_approvals").add(s);return console.log("✅ Approval request created:",a.id),a.id}catch(s){throw console.error("❌ Error creating approval request:",s),s}}async getApprovalsByStatus(n="pending",t=50){try{let e=this.db.collection("pending_task_approvals");return n!=="all"&&(e=e.where("status","==",n)),e=e.orderBy("requestedAt","desc").limit(t),(await e.get()).docs.map(a=>{var o,i;return{id:a.id,...a.data(),requestedAt:((o=a.data().requestedAt)==null?void 0:o.toDate())||null,reviewedAt:((i=a.data().reviewedAt)==null?void 0:i.toDate())||null}})}catch(e){throw console.error("❌ Error loading approvals:",e),e}}async approveRequest(n,t,e=""){var r;try{const s=window.firebaseFunctions||((r=window.firebase)==null?void 0:r.functions());if(!s)throw new Error("Firebase Functions not initialized");const o=await s.httpsCallable("approveTaskBudget")({approvalId:n,approvedMinutes:t,adminNotes:e});return console.log("✅ Task approved via Cloud Function:",o.data),o.data}catch(s){throw console.error("❌ Error approving request:",s),s}}async rejectRequest(n,t){var e;try{const r=window.firebaseFunctions||((e=window.firebase)==null?void 0:e.functions());if(!r)throw new Error("Firebase Functions not initialized");const a=await r.httpsCallable("rejectTaskBudget")({approvalId:n,rejectionReason:t});return console.log("✅ Task rejected via Cloud Function:",a.data),a.data}catch(r){throw console.error("❌ Error rejecting request:",r),r}}listenToPendingApprovals(n){return this.db.collection("pending_task_approvals").where("status","==","pending").orderBy("requestedAt","desc").onSnapshot(t=>{const e=t.docs.map(r=>{var s;return{id:r.id,...r.data(),requestedAt:((s=r.data().requestedAt)==null?void 0:s.toDate())||null}});n(e)})}}const d=new l;export{l as TaskApprovalService,d as taskApprovalService};
